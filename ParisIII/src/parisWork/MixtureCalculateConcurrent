package parisWork;

import java.util.Vector;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.eclipse.swt.widgets.ProgressBar;

import parisInit.State;

public class MixtureSearchConcurrent {

	private Vector<Mixture> mMixtures;
	private State mActiveState;
	private ProgressBar mProgressBar;
//    final protected static ExecutorService executor = Executors.newCachedThreadPool();
	protected static int nThreads = Runtime.getRuntime().availableProcessors();

	public MixtureSearchConcurrent(State activeState, Vector<Mixture> mixtures, ProgressBar progressBar) {
		mActiveState = activeState;
		mMixtures = mixtures;
		mProgressBar = progressBar;
	}
	
	public MixtureSearchConcurrent(State activeState, Vector<Mixture> mixtures) {
		mActiveState = activeState;
		mMixtures = mixtures;
	}
	
	public void search() throws Exception {

		System.out.println("Array size is " + mMixtures.size());

		int processors = Runtime.getRuntime().availableProcessors();
		System.out.println(Integer.toString(processors) + " processor" +
				(processors != 1 ? "s are " : " is ") + "available");

		ExecutorService executor = Executors.newFixedThreadPool(nThreads);
		
		int nTasks = 4*nThreads;
		Vector<Future<Void>> list = new Vector<Future<Void>>(nTasks);
		
		int stepsize = (mMixtures.size()/nTasks) + 1;
		int from = 0;
		int to = Math.min(from + stepsize, mMixtures.size());
		while (from < mMixtures.size()) {
			ConcurrentSearch task = new ConcurrentSearch(mMixtures, from, to);
			Future<Void> results = executor.submit(task);
			list.add(results);
			from = to;
			to = Math.min(from + stepsize, mMixtures.size());
		}
		
		executor.shutdown();
		
		int progressBefore = 0;
		double percent = 100.0/list.size();
		int cnt = 0;
		while (!executor.isTerminated()) {
			executor.awaitTermination(1000, TimeUnit.MILLISECONDS);
			cnt = 0;
			for (int i=0; i<list.size(); i++) {
				if (list.get(i).isDone()) cnt++;
			}
			if (!mProgressBar.getDisplay().readAndDispatch()) {
				int progress = (int)(cnt*percent);
				if (progress != progressBefore) mProgressBar.setSelection(progress);
				progressBefore = progress;
			}
		}

		return;
	}
	/**
	 * This illustrate the use of the Callable task framework.
	 */
	public class ConcurrentSearch implements Callable<Void> {

		/**
		 * 
		 */
		private static final long serialVersionUID = -5069206897899763709L;

		private Vector<Mixture> mMixtures;
		private int mFrom;
		private int mTo;

		public ConcurrentSearch(Vector<Mixture> mixtures, int from, int to) {
			mMixtures = mixtures;
			mFrom = from;
			mTo = to;
		}

		@Override
		public Void call() throws Exception {
			for (int i=mFrom; i<mTo; i++) {
				try {
					mMixtures.get(i).calculateMixtureScore(mActiveState);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
			return null;
		}

	}


}
